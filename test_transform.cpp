#include "transform.h"
#include <list>

// how big might a class of sudokus generated by transformations be?

bool find(list<sudoku*>* m, sudoku* s, const uint compare_param = EQ_ALL){
	for(list<sudoku*>::const_iterator i = m->begin(); i != m->end(); i++)
		if((*i)->is_equal(*s, compare_param)) return true;
	return false;
}

bool sud_insert(list<sudoku*>* m, sudoku* s, const uint compare_param = EQ_ALL){
	if(find( m, s, compare_param)) return false;
	else {
		m->insert(m->end(), s);
		return true;
	}
}

list<sudoku*> sud_class;
list<sudoku*> sud_todo;

#define PRINT_ROUND 100
int main(int argc, char** argv){
	char* filename;
	sudoku *su, *s;
	long uint count = 0;
	
	if(argc > 1) filename=argv[1]; else filename = "stdin";
	printf("reading file %s\n", filename);
	su = new sudoku(filename, 1);
	uint digits = su->getnum_digits();
	uint order = (uint)sqrt((double)digits);
	su->print();

	sud_insert(&sud_todo, su);
	while(!sud_todo.empty()){
		count++;
		su = sud_todo.front();
		sud_todo.pop_front();

		// if su is not in sud_class, insert it
		if(sud_insert(&sud_class, su)) {

			// do all possible transformations with s and store em in todo
			// swap all rows
			for(uint br = 0; br < order; br++) // boxrow
				for(uint row1 = 0; row1 < order; row1++)
					for(uint row2 = row1 + 1; row2 < order; row2++){
						s = new sudoku(*su);
						swap_rows(s, br * order + row1, br * order + row2);
						if(!sud_insert(&sud_todo,s, EQ_NONGEOMETRIC)) delete s;
					}
			// swap all boxrows
			for(uint br1 = 0; br1 < order; br1++) // boxrow1
				for(uint br2 = br1 + 1; br2 < order; br2++){ // boxrow2
					s = new sudoku(*su);
					swap_boxrows(s, br1, br2);
					if(!sud_insert(&sud_todo,s, EQ_NONGEOMETRIC)) delete s;
				}
			// transpose
			s = new sudoku(*su);
			transpose(s);
			if(!sud_insert(&sud_todo,s, EQ_NONGEOMETRIC)) delete s;

			// posspace transformation
			s = new sudoku(*su);
			posspace_transform(s);
			if(!sud_insert(&sud_todo,s, EQ_NONGEOMETRIC)) delete s;

			// ambigous rect
			uint x0,y0,x1,y1;
			x0=y0=x1=y1=0;
			while(find_next_ambigous_rect(su, x0, y0, x1, y1)){
				s = new sudoku(*su);
				ambigous_rect(s, x0, y0, x1, y1);
				if(!sud_insert(&sud_todo,s, EQ_NONGEOMETRIC)) delete s;
			}

		} else delete su;
		if(!(count % PRINT_ROUND)) printf("round %ld:\t%d sudokus in the class\n", count, sud_class.size());
		if(!(count % PRINT_ROUND)) printf("round %ld:\t%d sudokus in todo list\n", count, sud_todo.size());
	}
	printf("final round %ld:\t%d sudokus in todo list\n", count, sud_todo.size());
	printf("%d sudokus in the class\n",  sud_class.size());
	for(list<sudoku*>::iterator i = sud_class.begin(); i != sud_class.end(); i++){
		(*i)->print();
		printf("====\n");
	}

}
