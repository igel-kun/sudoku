#include "sudoku.h"
// how big might a class of sudokus generated by transformations be?

class sud_less {
public:
	// if the two sudokus are not equal, return the one with the least address...
	bool operator()(const sudoku* s1, const sudoku* s2) const{
		return (*s1 == *s2)?false:(s1 < s2);
	}
};

set<sudoku*,sud_less> sud_class;

#define PRINT_ROUND 100000
int main(int argc, char** argv){
	sudoku *su;
	long uint count = 0;
	
	uint x,y;
	bool bitfield[4];
	for(uint i = 0x1b0000; i < 0xffffff; i++){
		su = new sudoku(4);
		for(uint j = 0; j < 12; j++){
			x = j / 4;
			y = j % 4;
			su->get_cell(x,y)->set_content(1 + ((i >> (2*j)) & 3));
		}
		for(uint j = 0; j < 4; j++){
			for(uint k = 0; k < 4; k++) bitfield[k] = true;
			for(uint k = 0; k < 3; k++) bitfield[su->get_cell(k,j)->get_content() - 1] = false;
	 		su->get_cell(3,j)->set_content(bitfield[0]?1:(bitfield[1]?2:(bitfield[2]?3:4)));
		}
		if(su->is_valid()) {
			count++;
			sud_class.insert(su);
		} else delete su;
		if(!(i % PRINT_ROUND)) printf("round %x:\t%d sudokus in the class, %ld valid so far\n", i, sud_class.size(), count);
	}
	for(set<sudoku*,sud_less>::iterator i = sud_class.begin(); i != sud_class.end(); i++){
		(*i)->print();
		printf("=======\n");
	}
}
